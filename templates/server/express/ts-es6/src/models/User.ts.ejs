<%_ if (database === "mongodb") { _%>
import mongoose, { Schema, Document } from "mongoose";
<%_ if (auth !== "none") { _%>
import bcrypt from "bcryptjs";
import crypto from "crypto";
<%_ } _%>

export interface IUser extends Document {
  email: string;
<%_ if (auth !== "none") { _%>
  password?: string;
  comparePassword(candidatePassword: string): Promise<boolean>;
<%_ } _%>
<%_ if (auth === "passport") { _%>
  googleId?: string;
  githubId?: string;
<%_ } _%>
  name?: string;
}

const UserSchema: Schema = new Schema({
  email: { type: String, required: true, unique: true },
<%_ if (auth !== "none") { _%>
  password: { type: String, select: false },
<%_ } _%>
<%_ if (auth === "passport") { _%>
  googleId: { type: String, unique: true, sparse: true },
  githubId: { type: String, unique: true, sparse: true },
<%_ } _%>
  name: { type: String },
}, { timestamps: true });

<%_ if (auth !== "none") { _%>
UserSchema.pre<IUser>("save", async function(next) {
  if (!this.isModified("password")) return next();
  if (this.password) {
    const preHashed = crypto.createHash("sha256").update(this.password).digest("hex");
    this.password = await bcrypt.hash(preHashed, 12);
  }
  next();
});

UserSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  if (!this.password) return false;
  const preHashed = crypto.createHash("sha256").update(candidatePassword).digest("hex");
  return await bcrypt.compare(preHashed, this.password);
};
<%_ } _%>

export default mongoose.model<IUser>("User", UserSchema);

<%_ } else if (database === "postgresql" && orm === "pg") { _%>
import { pool } from "../config/db";
<%_ if (auth !== "none") { _%>
import bcrypt from "bcryptjs";
import crypto from "crypto";
<%_ } _%>

export interface User {
  id?: number;
  email: string;
<%_ if (auth !== "none") { _%>
  password?: string;
<%_ } _%>
  name?: string;
  created_at?: Date;
}

export class UserModel {
  static async create(user: User): Promise<User> {
    const { email, name, password } = user;
<%_ if (auth !== "none") { _%>
    const preHashed = password ? crypto.createHash("sha256").update(password).digest("hex") : null;
    const hashedPassword = preHashed ? await bcrypt.hash(preHashed, 12) : null;
    const query = "INSERT INTO users (email, password, name) VALUES ($1, $2, $3) RETURNING *";
    const values = [email, hashedPassword, name];
<%_ } else { _%>
    const query = "INSERT INTO users (email, name) VALUES ($1, $2) RETURNING *";
    const values = [email, name];
<%_ } _%>

    const result = await pool.query(query, values);
    return result.rows[0];
  }

  static async findByEmail(email: string): Promise<User | null> {
    const query = "SELECT * FROM users WHERE email = $1";
    const result = await pool.query(query, [email]);
    return result.rows[0] || null;
  }

  static async comparePassword(password: string, hashedPassword: string): Promise<boolean> {
    const preHashed = crypto.createHash("sha256").update(password).digest("hex");
    return await bcrypt.compare(preHashed, hashedPassword);
  }

  static async findById(id: number): Promise<User | null> {
    const query = "SELECT * FROM users WHERE id = $1";
    const result = await pool.query(query, [id]);
    return result.rows[0] || null;
  }
}
<%_ } _%>
<%_ if (database === "postgresql" && orm === "prisma") { _%>
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();

export interface User {
  id: string;
  email: string;
  name?: string;
}

// Prisma model is handled by the generated client
export const UserModel = prisma.user;
<%_ } _%>
